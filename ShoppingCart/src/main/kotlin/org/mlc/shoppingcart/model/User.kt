package org.mlc.shoppingcart.model

import jakarta.persistence.*
import org.hibernate.annotations.NaturalId
import org.mlc.shoppingcart.utils.UserRole


/**
 * Represents a user within the e-commerce system.
 * Each user has a unique identifier, an email for login, a hashed password,
 * a personal shopping [Cart], and a collection of their past [Order]s.
 *
 * This class is an `@Entity` managed by JPA, mapping directly to a database table.
 */
@Entity
data class User(
    /**
     * The unique identifier for the user.
     * It's auto-generated by the database upon creation.
     */
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    /**
     * The user's email address, used for login and unique identification.
     * This field cannot be null.
     */
    @NaturalId
    @Column(nullable = false, unique = true)
    var email: String,

    /**
     * The user's password, which should be stored as a hashed value for security.
     * This field cannot be null.
     */
    @Column(nullable = false)
    var password: String,

    @Column(name = "first_name", nullable = false)
    var firstName: String,

    @Column(name = "last_name", nullable = false)
    var lastName: String,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var role: UserRole = UserRole.USER,


    /**
     * The one-to-one relationship with the user's shopping [Cart].
     * `mappedBy = "user"` indicates that the `user` field in the [Cart] entity
     * is the owning side. `CascadeType.ALL` ensures that operations on the User
     * (e.g., persisting a new user) also affect their cart. `orphanRemoval = true`
     * means if a cart is disassociated from a user, it will be deleted.
     */
    @OneToOne(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true)
    var cart: Cart? = null,

    /**
     * A mutable set of [Order]s placed by this user.
     * This is a one-to-many relationship, meaning one user can have multiple orders.
     * `mappedBy = "user"` indicates that the `user` field in the [Order] entity
     * is the owning side. `CascadeType.ALL` ensures operations on the User also affect
     * their orders (e.g., deleting a user would delete their orders).
     * `orphanRemoval = true` means if an order is removed from this set, it's also
     * deleted from the database. `FetchType.LAZY` ensures orders are loaded only when accessed.
     */
    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true, fetch = FetchType.LAZY)
    val orders: MutableSet<Order> = mutableSetOf(),
){
    /**
     * Provides a concise string representation of the [User] entity.
     * This override is manually implemented to prevent potential `StackOverflowError`s
     * that can occur with auto-generated `toString()` methods in `data class` entities
     * due to complex, bidirectional relationships.
     * It avoids traversing lazy-loaded collections and sensitive data like the full password.
     */
    override fun toString(): String {
        return "User(id=$id, email='$email', cartId=${cart?.id}, ordersCount=${orders.size})"
    }
}